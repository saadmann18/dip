#pragma once

#include "image.h"
#include "imagesequence.h"

#include <math.h>

namespace GET
{

	/** Discrete Fourier Transform.
	 *
	 * The Fourier space generated by this Discrete Fourier Transform gives the frequencies
	 * relative to the unit length 1. I.e. it does not use circular frequencies
	 * (these would be specified relative to a unit length of 2*pi).
	 *
	 * Discrete Fourier transformation according to Jaehne - digital image processing,
	 * formula 2.25-2.27 (2D-DFT according to formula 2.89)
	 *
	 * @author Holger T�ubig
	 * @version PRELIMINARY DONE.
	 *
	 * @note Source of the first implementation: Jaehne - Digital image processing (formulae: 2.25-2.27; 2.89)
	 *
	 * @todo Introduce additional transformation methods float->Complex and float<-Complex to reduce
	 * wasted copying time when an Image<float> is present or needed in position space.
	 */
	class DFT
	{
	public:
		/** Variants when the scaling of the Discrete Fourier Transform is performed
		 */
		enum ScalingType
		{
			NOSCALING,				  ///< do not perform scaling
			SYMMETRICAL_SCALING,	  ///< symmetrical scaling
			SCALE_ON_TRANSFORMATION,  ///< Scaling on transformation
			SCALE_ON_RETRANSFORMATION ///< Scaling on inverse transformation
		};

	private:
		/** Specifies how the scaling is to be performed */
		enum ScalingType m_scaling;

	public:
		/** Constructor.
		 *
		 * @param scaling type of scaling
		 */
		DFT(ScalingType scaling = SCALE_ON_TRANSFORMATION);

		/** Destructor */
		~DFT(){};

		/**
		 * perform one-dimensional discrete Fourier transformation
		 *
		 * @param original_image Input - image in position space
		 * @param fourier_image  Output - image in Fourier space
		 */
		void doFourierTransform(const Image<Complex> &original_image, Image<Complex> &fourier_image);

		/**
		 * perform two-dimensional discrete Fourier transformation
		 *
		 * @param original_image Input - image in position space
		 * @param fourier_image  Output - image in Fourier space
		 */
		void doFourierTransform2D(const Image<Complex> &original_image, Image<Complex> &fourier_image);

		/**
		 * perform back-transformation of the one-dimensional discrete Fourier transform
		 *
		 * @param fourier_image  Input - image in Fourier space
		 * @param original_image Output - image in local space
		 */
		void doInvFourierTransform(const Image<Complex> &fourier_image, Image<Complex> &original_image);

		/**
		 * perform back-transformation of the two-dimensional discrete Fourier transform
		 *
		 * @param fourier_image  Input - image in Fourier space
		 * @param original_image Output - image in local space
		 */
		void doInvFourierTransform2D(const Image<Complex> &fourier_image, Image<Complex> &original_image);

		/**
		 * perform back-transformation of the one-dimensional discrete Fourier transform.
		 * Only the #real part# of the inverse-transformed image in spatial space is determined.
		 *
		 * @param fourier_image  Input - image in Fourier space
		 * @param original_image Output - Realteil des Bildes im Ortsraum
		 *
		 * @todo Eliminate wasting time by completely calculating the complex image in the spatial domain
		 * and then copying it (just calculate the real part at once).
		 */
		void doInvFourierTransform(const Image<Complex> &fourier_image, Image<float> &original_image);

		/**
		 * perform back-transformation of the two-dimensional discrete Fourier transform.
		 * Only the #real part# of the inverse-transformed image in spatial space is determined.
		 *
		 * @param fourier_image  Input - image in Fourier space
		 * @param original_image Output - Realteil des Bildes im Ortsraum
		 *
		 * @todo Eliminate wasting time by completely calculating the complex image in the spatial domain
		 * and then copying it (just calculate the real part at once)
		 */
		void doInvFourierTransform2D(const Image<Complex> &fourier_image, Image<float> &original_image);

		/** Nyquist modulation (centering in frequency space/position space).
		 *
		 * For the Nyquist modulation, every second element of an image is multiplied by -1.
		 * The modulation corresponds to a multiplication of each individual pixel of the image
		 * by (-1)^(x+y). Here, x and y are the coordinates of the pixel that is currently being processed.
		 *
		 * #The following applies to the Fourier transformation:# \n If the Nyquist modulation is
		 * carried out in the spatial domain, the associated Fourier transformation is centered in the
		 * frequency domain (shift in the frequency domain by half an image width and image height).
		 * The Nyquist modulation is also used to undo this centering (shift) after back-transformation into
		 * the spatial domain.\n Analogously, the associated image can also be obtained by executing the Nyquist
		 * modulation in the frequency domain be centered/decentered in spatial space.
		 *
		 * @param image Image to apply Nyquist modulation to. The operation is performed in this picture.
		 */
		template <typename PTYPE>
		void doNyquistModulation(Image<PTYPE> &image);

		/** Nyquist modulation (centering in frequency space/position space).
		 *
		 * For the Nyquist modulation, every second element of an image is multiplied by -1.
		 * The modulation corresponds to a multiplication of each individual pixel of the
		 * image by (-1)^(x+y). Here, x and y are the coordinates of the pixel that
		 * is currently being processed.
		 *
		 * #The following applies to the Fourier transformation:# \n If the Nyquist modulation is
		 * carried out in the spatial domain, the associated Fourier transformation is centered in the
		 * frequency domain (shift in the frequency domain by half an image width and image height).
		 * The Nyquist modulation is also used to undo this centering (shift) after back-transformation into
		 * the spatial domain.\n Analogously, the associated image can also be obtained by executing the Nyquist
		 * modulation in the frequency domain be centered/decentered in spatial space.
		 *
		 * @param input Input image
		 * @param output Nyquist modulated image
		 */
		template <typename PTYPE>
		void doNyquistModulation(const Image<PTYPE> &input, Image<PTYPE> &output);

		/**
		 * Set scaling type
		 */
		inline void setScaling(ScalingType scaling) { m_scaling = scaling; };

		/**
		 * Query scaling type
		 */
		inline ScalingType getScaling() { return m_scaling; };

	protected:
		/** Perform scaling on transformation according to m_scaling
		 *
		 * @see m_scaling
		 */
		inline void doFourierTransformScaling(Image<Complex> &fourier_image, int size);

		/** Carry out scaling for inverse transformation according to m_scaling */
		inline void doInvFourierTransformScaling(Image<Complex> &original_image, int size);

	private:
		/** Implementation of the Discrete Fourier Transform algorithm (one-dimensional)
		 *
		 * @param src Pointer to the image data of the input (position space)
		 * @param fourier Pointer to the image data of the output (Fourier space)
		 * @param size Size of the input (or output)
		 */
		void doDFT(Complex *src, Complex *fourier, int size);

		/** Implementation der R�cktransformation der Diskreten Fouriertransformation (eindimensional)
		 *
		 * @param fourier Pointer to the image data of the input (Fourier domain)
		 * @param dest Pointer to the image data of the output (Spatial domain)
		 * @param size Size of the input (or output)
		 */
		void doInvDFT(Complex *fourier, Complex *dest, int size);

		/**
		 * Performs pre-calculations for doDFT() and doInvDFT(), which do not have to be recalculated with each call.
		 *
		 * The pre-calculations only have to be carried out again if the size has changed when doDFT() or doInvDFT() is called.
		 *
		 * @param size Size with which doDFT() or doInvDFT() was called.
		 */
		void doDFTPrecomputations(int size);

		/**
		 * Stores the pre-calculation of the weights used in doDFT() or doInvDFT().
		 */
		Image<Complex> m_precomputed_weights;
	};

	/* ************************************************************************** */
	/* *** Implementation of the templates and INLINE methods ******************* */
	/* ************************************************************************** */

	/* ************************************************************************** */
	template <typename PTYPE>
	void DFT::doNyquistModulation(Image<PTYPE> &image)
	/* ************************************************************************** */
	{
		//
		// Get image data
		//
		int width = image.getWidth();
		int height = image.getHeight();
		PTYPE *data = image.getData();

		//
		// Set seed - pixel (0,0) remains constant
		//
		bool flip;
		bool start_line = false;

		//
		// Loop through entire image and multiply every other pixel by -1
		//
		for (int y = 0; y < height; ++y)
		{
			flip = start_line;
			start_line = !start_line;
			for (int x = 0; x < width; ++x)
			{
				if (flip)
					*data *= -1;
				++data;
				flip = !flip;
			}
		}
	}

	/* ************************************************************************** */
	template <typename PTYPE>
	void DFT::doNyquistModulation(const Image<PTYPE> &input, Image<PTYPE> &output)
	/* ************************************************************************** */
	{
		//
		// Image size test
		//
		int width = input.getWidth();
		int height = input.getHeight();

		if ((output.getWidth() != width) || (output.getHeight() != height))
		{
			output.resize(width, height);
		}

		//
		// Get data pointer
		//
		PTYPE *inp = input.getData();
		PTYPE *outp = output.getData();

		//
		// Set seed - pixel (0,0) remains constant
		//
		bool flip;
		bool start_line = false;

		//
		// Loop through entire image and multiply every other pixel by -1
		//
		for (int y = 0; y < height; ++y)
		{
			flip = start_line;
			start_line = !start_line;
			for (int x = 0; x < width; ++x)
			{
				if (flip)
				{
					*(outp++) = -(*(inp++));
				}
				else
				{
					*(outp++) = *(inp++);
				}
				flip = !flip;
			}
		}
	}

	/* ************************************************************************** */
	inline void DFT::doFourierTransformScaling(Image<Complex> &fourier_image, int size)
	/* ************************************************************************** */
	{
		switch (m_scaling)
		{
		case NOSCALING:
		case SCALE_ON_RETRANSFORMATION:
			break;
		case SYMMETRICAL_SCALING:
			fourier_image.mul(1.0f / sqrtf(size));
			break;
		case SCALE_ON_TRANSFORMATION:
			fourier_image.mul(1.0f / size);
			break;
		}
	}

	/* ************************************************************************** */
	inline void DFT::doInvFourierTransformScaling(Image<Complex> &original_image, int size)
	/* ************************************************************************** */
	{
		switch (m_scaling)
		{
		case NOSCALING:
		case SCALE_ON_TRANSFORMATION:
			break;
		case SYMMETRICAL_SCALING:
			original_image.mul(1.0f / sqrtf(size));
			break;
		case SCALE_ON_RETRANSFORMATION:
			original_image.mul(1.0f / size);
			break;
		}
	}

} /* namespace GET */
